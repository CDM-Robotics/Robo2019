package team6072.robo2019.subsystems;

import com.kauailabs.navx.frc.AHRS;
import com.kauailabs.navx.frc.ITimestampedDataSubscriber;

import java.util.Timer;
import java.util.TimerTask;

import com.kauailabs.navx.AHRSProtocol.AHRSUpdateBase;

import edu.wpi.first.wpilibj.SPI;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import team6072.robo2019.logging.*;

/**
 * Wrap the AHRS in a singleton class to ensure that it is only created once
 */
public class NavXSys {

    private static final LogWrapper mLog = new LogWrapper(NavXSys.class.getName());

    private static NavXSys mInstance;


    protected double mYawDegrees;
    protected double mYawRateDegreesPerSecond;
    protected final long kInvalidTimestamp = -1;
    protected long mLastSensorTimestampMs;
    protected long mLastSystemTimestamp;


    //------------------------------------------

    /**
     * Implement a callback that will receive timestamped data from the NavX
     * 
     * The ITimestampedDataSubscriber interface provides a method for consumers of
     * navX-Model device data to be rapidly notified whenever new data has arrived.
     * - timestampedDataReceived(): reception of sensor-timestamped data A "sensor"
     * timestamp is provided, generated by the navX-Model device, which is at
     * millisecond resolution. A "system timestamp", also at millisecond resolution,
     * is also provided, which represents as accurately as possible the time at
     * which the data was acquired from the navX-Model device. Note that the "system
     * timestamp" typically has more jitter since it is generated by the host of the
     * navX-Model device. Thus, in general sensor timestamps are preferred, as they
     * are generated by the navX-Model device motion processor and has a greater
     * accuracy (+/- 1ms) than the system timestamp which is vulnerable to latencies
     * introduced by the host operating system. The system timestamp is provided to
     * allow performance monitoring of the navX-Model device host's data acquisition
     * process.
     */
    class DataSubscriber implements ITimestampedDataSubscriber {
        @Override
        public void timestampedDataReceived(long system_timestamp,
                            long sensor_timestamp,
                            AHRSUpdateBase update,
                            java.lang.Object context) {
            synchronized (NavXSys.this) {
                if (mLastSensorTimestampMs != kInvalidTimestamp && mLastSensorTimestampMs < sensor_timestamp) {
                    mYawRateDegreesPerSecond = 1000.0 * (mYawDegrees - update.yaw)
                            / (double) (sensor_timestamp - mLastSensorTimestampMs);
                }
                mLastSensorTimestampMs = sensor_timestamp;
                mLastSystemTimestamp = system_timestamp;
                mYawDegrees = update.yaw;
            }
        }
    }


    //------------------------------------------

    public static NavXSys getInstance() {
        if (mInstance == null) {
            mInstance = new NavXSys();
        }
        return mInstance;
    }

    private AHRS mNavX;

    private NavXSys() {
        mLog.info("NavXSys.ctor  -----------------------------------------");
        try {
            /* Communicate w/navX-MXP via the MXP SPI Bus. */
            mNavX = new AHRS(SPI.Port.kMXP, (byte) 100);
            resetState();
            mNavX.registerCallback(new DataSubscriber(), null);

            // set up a timer to report when NavX has calibrated
            TimerTask taskCheckCal = new TimerTask() {
                public void run() {
                    if (!mNavX.isCalibrating()) {
                        mLog.info("NavXSys calibrated: YawAxis: " + mNavX.getBoardYawAxis().board_axis.getValue()
                                + "  firmware: " + mNavX.getFirmwareVersion() + "  isConnected: " + mNavX.isConnected()
                                + "  angle: " + mNavX.getAngle());
                        cancel();
                    }
                }
            };
            Timer timer = new Timer("Timer");
            long delay = 1000L;
            long period = 1000L;
            timer.scheduleAtFixedRate(taskCheckCal, delay, period);
        } catch (Exception ex) {
            mLog.severe("******************************************************************");
            mLog.severe(ex, "NavXSys.ctor:  Error instantiating navX-MXP:  " + ex.getMessage());
            mLog.severe("******************************************************************");
            throw ex;
        }
    }


    private void resetState() {
        mLastSensorTimestampMs = kInvalidTimestamp;
        mYawDegrees = 0.0;
        mYawRateDegreesPerSecond = 0.0;
    }


    public AHRS getNavX() {
        return mNavX;
    }

    public void zeroYawHeading() {
        mLog.debug("NavX: setting Yaw to 0");
        mNavX.zeroYaw(); // resets the angle to 0
    }


    // get the yaw (twist around z)
    public double getYawHeading() {
        return mYawDegrees;
    }

    public double getYawRateDegressPerSec() {
        return mYawRateDegreesPerSecond;
    }

    public long getSensorTimestamp() {
        return mLastSensorTimestampMs;
    }

    public long getSystemTimestamp() {
        return mLastSystemTimestamp;
    }

    // get navX angle from 0 in degrees
    public double getAngle() {
        return mNavX.getAngle();
    }


    /**
     * Return pitch from -180 to +180
     */
    public float getPitch() {
        return mNavX.getPitch();
    }


    public void outputAngles() {
        // System.out.printf("NavXSys -> getAngle: %.3f angleAjd: %.3f yaw:%.3f \r\n",
        // mAhrs.getAngle(), mAhrs.getAngleAdjustment(), mAhrs.getYaw());
    }

    /**
     * Provide detailed info about the NavX for SmartDashboard
     */
    public void logNavX() {
        AHRS ahrs = mNavX;
        /* Display 6-axis Processed Angle Data */
        SmartDashboard.putBoolean("NavX/IMU_Connected", ahrs.isConnected());
        SmartDashboard.putBoolean("NavX/IMU_IsCalibrating", ahrs.isCalibrating());
        SmartDashboard.putNumber("NavX/IMU_Yaw", ahrs.getYaw());
        SmartDashboard.putNumber("NavX/IMU_Pitch", ahrs.getPitch());
        SmartDashboard.putNumber("NavX/IMU_Roll", ahrs.getRoll());

        /* Display tilt-corrected, Magnetometer-based heading (requires */
        /* magnetometer calibration to be useful) */

        SmartDashboard.putNumber("NavX/IMU_CompassHeading", ahrs.getCompassHeading());

        /* Display 9-axis Heading (requires magnetometer calibration to be useful) */
        SmartDashboard.putNumber("NavX/IMU_FusedHeading", ahrs.getFusedHeading());

        /* These functions are compatible w/the WPI Gyro Class, providing a simple */
        /* path for upgrading from the Kit-of-Parts gyro to the navx-MXP */

        SmartDashboard.putNumber("NavX/IMU_TotalYaw", ahrs.getAngle());
        SmartDashboard.putNumber("NavX/IMU_YawRateDPS", ahrs.getRate());

        /* Display Processed Acceleration Data (Linear Acceleration, Motion Detect) */

        SmartDashboard.putNumber("NavX/IMU_Accel_X", ahrs.getWorldLinearAccelX());
        SmartDashboard.putNumber("NavX/IMU_Accel_Y", ahrs.getWorldLinearAccelY());
        SmartDashboard.putBoolean("NavX/IMU_IsMoving", ahrs.isMoving());
        SmartDashboard.putBoolean("NavX/IMU_IsRotating", ahrs.isRotating());

        /* Display estimates of velocity/displacement. Note that these values are */
        /* not expected to be accurate enough for estimating robot position on a */
        /* FIRST FRC Robotics Field, due to accelerometer noise and the compounding */
        /* of these errors due to single (velocity) integration and especially */
        /* double (displacement) integration. */

        SmartDashboard.putNumber("NavX/Velocity_X", ahrs.getVelocityX());
        SmartDashboard.putNumber("NavX/Velocity_Y", ahrs.getVelocityY());
        SmartDashboard.putNumber("NavX/Displacement_X", ahrs.getDisplacementX());
        SmartDashboard.putNumber("NavX/Displacement_Y", ahrs.getDisplacementY());

        /* Display Raw Gyro/Accelerometer/Magnetometer Values */
        /* NOTE: These values are not normally necessary, but are made available */
        /* for advanced users. Before using this data, please consider whether */
        /* the processed data (see above) will suit your needs. */

        SmartDashboard.putNumber("NavX/RawGyro_X", ahrs.getRawGyroX());
        SmartDashboard.putNumber("NavX/RawGyro_Y", ahrs.getRawGyroY());
        SmartDashboard.putNumber("NavX/RawGyro_Z", ahrs.getRawGyroZ());
        SmartDashboard.putNumber("NavX/RawAccel_X", ahrs.getRawAccelX());
        SmartDashboard.putNumber("NavX/RawAccel_Y", ahrs.getRawAccelY());
        SmartDashboard.putNumber("NavX/RawAccel_Z", ahrs.getRawAccelZ());
        SmartDashboard.putNumber("NavX/RawMag_X", ahrs.getRawMagX());
        SmartDashboard.putNumber("NavX/RawMag_Y", ahrs.getRawMagY());
        SmartDashboard.putNumber("NavX/RawMag_Z", ahrs.getRawMagZ());
        SmartDashboard.putNumber("NavX/IMU_Temp_C", ahrs.getTempC());

        /* Omnimount Yaw Axis Information */
        /* For more info, see http://navx-mxp.kauailabs.com/installation/omnimount */
        AHRS.BoardYawAxis yaw_axis = ahrs.getBoardYawAxis();
        SmartDashboard.putString("NavX/YawAxisDirection", yaw_axis.up ? "Up" : "Down");
        SmartDashboard.putNumber("NavX/YawAxis", yaw_axis.board_axis.getValue());

        /* Sensor Board Information */
        SmartDashboard.putString("NavX/FirmwareVersion", ahrs.getFirmwareVersion());

        /* Quaternion Data */
        /* Quaternions are fascinating, and are the most compact representation of */
        /* orientation data. All of the Yaw, Pitch and Roll Values can be derived */
        /* from the Quaternions. If interested in motion processing, knowledge of */
        /* Quaternions is highly recommended. */
        SmartDashboard.putNumber("NavX/QuaternionW", ahrs.getQuaternionW());
        SmartDashboard.putNumber("NavX/QuaternionX", ahrs.getQuaternionX());
        SmartDashboard.putNumber("NavX/QuaternionY", ahrs.getQuaternionY());
        SmartDashboard.putNumber("NavX/QuaternionZ", ahrs.getQuaternionZ());

        /* Connectivity Debugging Support */
        SmartDashboard.putNumber("NavX/IMU_Byte_Count", ahrs.getByteCount());
        SmartDashboard.putNumber("NavX/IMU_Update_Count", ahrs.getUpdateCount());
    }


}